<!doctype html>
<html>
<head>
<meta charset="utf-8">
<title>MCQ Table-format DOCX Generator (No background)</title>
<meta name="viewport" content="width=device-width,initial-scale=1">
<style>
  body{font-family: Arial; margin:14px}
  .wrap{display:flex; gap:12px; flex-wrap:wrap}
  .col{flex:1; min-width:300px; border:1px solid #ddd; padding:12px; border-radius:6px}
  input, textarea, select { width:100%; padding:8px; margin:6px 0; box-sizing:border-box; }
  button{padding:10px 14px; margin-right:8px; background:#0b7a3e; color:#fff; border:0; border-radius:6px; cursor:pointer}
  .muted{color:#666; font-size:13px}
  .preview-item{border:1px dashed #ccc; padding:8px; margin:8px 0}
  table.preview-table{width:100%; border-collapse:collapse}
  table.preview-table td{border:1px solid #ccc; padding:6px; vertical-align:top}
  .hdr{font-weight:700; background:transparent}
</style>
</head>
<body>
<h2>MCQ → Table DOCX (No background)</h2>
<p class="muted">हर प्रश्न एक ही table में: Left = field name, Right = value. Tables बिना background के export होंगे।</p>

<div class="wrap">
  <div class="col">
    <label>Module</label>
    <input id="module" placeholder="Hindi">

    <label>Question</label>
    <textarea id="question" rows="3" placeholder="Question statement"></textarea>

    <label>Option A</label>
    <input id="optA" placeholder="Option A">
    <label>Option B</label>
    <input id="optB" placeholder="Option B">
    <label>Option C</label>
    <input id="optC" placeholder="Option C">
    <label>Option D</label>
    <input id="optD" placeholder="Option D">

    <label>Answer (A/B/C/D)</label>
    <input id="answer" maxlength="1" placeholder="A">

    <label>Solution</label>
    <textarea id="solution" rows="3"></textarea>

    <div style="display:flex; gap:8px">
      <div style="flex:1">
        <label>Positive Marks</label>
        <input id="pm" value="1">
      </div>
      <div style="flex:1">
        <label>Negative Marks</label>
        <input id="nm" value="0.6">
      </div>
    </div>

    <label>Language</label>
    <select id="language">
      <option value="hi">hi</option>
      <option value="en">en</option>
    </select>

    <div style="margin-top:10px">
      <button id="addBtn">Add Question</button>
      <button id="clearBtn" style="background:#999">Clear Fields</button>
    </div>

    <hr>

    <div>
      <button id="exportBtn" style="background:#0066cc">Export DOCX (tables)</button>
      <span class="muted"> → Desktop recommended</span>
    </div>
  </div>

  <div class="col">
    <h3>Preview</h3>
    <div id="previewArea" class="muted">No questions added.</div>
    <div style="margin-top:10px">
      <button id="removeLast" style="background:#c0392b">Remove Last</button>
      <button id="resetAll" style="background:#7f8c8d">Clear All</button>
    </div>
  </div>
</div>

<script>
/* State */
let questions = [];
let qno = 1;

function val(id){ return document.getElementById(id).value.trim(); }
function setVal(id,v){ document.getElementById(id).value = v || ''; }

document.getElementById('addBtn').addEventListener('click', () => {
  const module = val('module') || 'General';
  const question = val('question');
  if(!question){ alert('Question डालो'); return; }
  const item = {
    module,
    questionno: qno++,
    question,
    type: 'mcq',
    option: [val('optA'), val('optB'), val('optC'), val('optD')],
    answer: val('answer').toUpperCase(),
    solution: val('solution'),
    pm: val('pm') || '1',
    nm: val('nm') || '0',
    language: val('language') || 'hi'
  };
  questions.push(item);
  renderPreview();
  clearFields(false);
});

document.getElementById('clearBtn').addEventListener('click', ()=> clearFields(true));
document.getElementById('removeLast').addEventListener('click', ()=> {
  if(questions.length===0) return alert('No questions to remove');
  if(!confirm('Remove last question?')) return;
  questions.pop();
  qno = questions.length ? (questions[questions.length-1].questionno + 1) : 1;
  renderPreview();
});
document.getElementById('resetAll').addEventListener('click', ()=> {
  if(!confirm('Remove all questions?')) return;
  questions = []; qno = 1; renderPreview();
});

function clearFields(all=true){
  if(all) setVal('module','');
  setVal('question','');
  setVal('optA',''); setVal('optB',''); setVal('optC',''); setVal('optD','');
  setVal('answer',''); setVal('solution','');
  setVal('pm','1'); setVal('nm','0.6');
}

/* Preview: show each question as small HTML table */
function renderPreview(){
  const area = document.getElementById('previewArea');
  if(questions.length===0){ area.innerHTML = '<div class="muted">No questions added.</div>'; return; }
  area.innerHTML = '';
  questions.forEach(q=>{
    const tbl = document.createElement('table');
    tbl.className = 'preview-table';
    // helper to add row
    function addRow(name, valTxt, boldLeft=true){
      const tr = document.createElement('tr');
      const td1 = document.createElement('td');
      td1.textContent = name;
      if(boldLeft) td1.style.fontWeight = '700';
      const td2 = document.createElement('td');
      td2.textContent = valTxt;
      tr.appendChild(td1); tr.appendChild(td2);
      tbl.appendChild(tr);
    }
    addRow('Module', q.module);
    addRow('questionno', q.questionno);
    addRow('Question', q.question, false);
    addRow('Type', q.type);
    // options - four rows with same field name "option"
    addRow('option', q.option[0] || '');
    addRow('option', q.option[1] || '');
    addRow('option', q.option[2] || '');
    addRow('option', q.option[3] || '');
    addRow('answer', q.answer || '');
    addRow('Solution', q.solution || '', false);
    addRow('Positive Marks', q.pm);
    addRow('Negative Marks', q.nm);
    addRow('language', q.language || '');
    area.appendChild(tbl);
    area.appendChild(document.createElement('br'));
  });
}

/* XML / DOCX generation helpers */
function xmlEscape(s){
  if(s==null) return '';
  return s.toString()
    .replace(/&/g,'&amp;')
    .replace(/</g,'&lt;')
    .replace(/>/g,'&gt;')
    .replace(/"/g,'&quot;')
    .replace(/'/g,'&apos;');
}

/* Build a single question table: each field is a row with two cells (left header, right value) */
function makeQuestionTableXml(q){
  const rows = [];
  function r(name, value, boldLeft){
    const leftRunPr = boldLeft ? '<w:rPr><w:b/></w:rPr>' : '';
    return `<w:tr>
      <w:tc>
        <w:p><w:r>${leftRunPr}<w:t>${xmlEscape(name)}</w:t></w:r></w:p>
      </w:tc>
      <w:tc>
        <w:p><w:r><w:t>${xmlEscape(value)}</w:t></w:r></w:p>
      </w:tc>
    </w:tr>`;
  }
  rows.push(r('Module', q.module, true));
  rows.push(r('questionno', q.questionno, true));
  rows.push(r('Question', q.question, false));
  rows.push(r('Type', q.type, true));
  rows.push(r('option', q.option[0]||'', false));
  rows.push(r('option', q.option[1]||'', false));
  rows.push(r('option', q.option[2]||'', false));
  rows.push(r('option', q.option[3]||'', false));
  rows.push(r('answer', q.answer||'', true));
  rows.push(r('Solution', q.solution||'', false));
  rows.push(r('Positive Marks', q.pm||'', true));
  rows.push(r('Negative Marks', q.nm||'', true));
  rows.push(r('language', q.language||'', true));

  // Wrap table; no extra spacer paragraphs between tables
  return `<w:tbl>
    ${rows.join('\n')}
  </w:tbl>`;
}

/* Build full document.xml -> simply concatenate question tables one after another */
function buildDocumentXml(questionsList){
  let body = '';
  questionsList.forEach(q=>{
    body += makeQuestionTableXml(q);
    // no separator paragraph — tables will follow directly
  });

  const documentXml = `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
  <w:document xmlns:w="http://schemas.openxmlformats.org/wordprocessingml/2006/main">
    <w:body>
      ${body}
      <w:p><w:r><w:t></w:t></w:r></w:p>
    </w:body>
  </w:document>`;
  return documentXml;
}

/* minimal other parts for docx */
const contentTypesXml = `<?xml version="1.0" encoding="UTF-8"?>
<Types xmlns="http://schemas.openxmlformats.org/package/2006/content-types">
  <Default Extension="rels" ContentType="application/vnd.openxmlformats-package.relationships+xml"/>
  <Default Extension="xml" ContentType="application/xml"/>
  <Override PartName="/word/document.xml" ContentType="application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml"/>
</Types>`;

const relsRelsXml = `<?xml version="1.0" encoding="UTF-8"?>
<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships"></Relationships>`;

const docRelsXml = `<?xml version="1.0" encoding="UTF-8"?>
<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships"></Relationships>`;

/* ZIP builder (store method) */
function makeZipBuffer(files){
  function str2buf(s){ return new TextEncoder().encode(s); }
  function uint32LE(n){ return [n & 0xff, (n>>8)&0xff, (n>>16)&0xff, (n>>24)&0xff]; }
  const crcTable = (function(){ let c; const table = new Uint32Array(256); for(let n=0;n<256;n++){ c=n; for(let k=0;k<8;k++){ c = c & 1 ? 0xEDB88320 ^ (c>>>1) : c>>>1; } table[n]=c>>>0; } return table; })();
  function crc32(buf){ let crc = 0 ^ (-1); for(let i=0;i<buf.length;i++) crc = (crc>>>8) ^ crcTable[(crc ^ buf[i]) & 0xff]; return (crc ^ (-1)) >>> 0; }

  const localParts = [];
  const centralParts = [];
  let offset = 0;
  for(const name in files){
    const content = files[name];
    const data = str2buf(content);
    const fname = str2buf(name);
    const crc = crc32(data);
    const compSize = data.length, uncompSize = data.length;
    const lh = new Uint8Array(30 + fname.length);
    lh.set([0x50,0x4b,0x03,0x04],0);
    lh.set([20,0],4);
    lh.set([0,0],6);
    lh.set([0,0],8);
    lh.set([0,0,0,0],10);
    lh.set(uint32LE(crc),14);
    lh.set(uint32LE(compSize),18);
    lh.set(uint32LE(uncompSize),22);
    lh.set([fname.length & 0xff, (fname.length>>8)&0xff],26);
    lh.set(fname,30);
    localParts.push({lh, data});
    offset += lh.length + data.length;

    const ch = new Uint8Array(46 + fname.length);
    ch.set([0x50,0x4b,0x01,0x02],0);
    ch.set([20,0],4); ch.set([20,0],6);
    ch.set([0,0],8); ch.set([0,0],10);
    ch.set([0,0,0,0],12);
    ch.set(uint32LE(crc),16);
    ch.set(uint32LE(compSize),20);
    ch.set(uint32LE(uncompSize),24);
    ch.set([fname.length & 0xff, (fname.length>>8)&0xff],28);
    ch.set([0,0,0,0],30); ch.set([0,0,0,0],32);
    ch.set([0,0],36); ch.set([0,0,0,0],38);
    const relOff = offset - (lh.length + data.length);
    ch.set(uint32LE(relOff),42);
    ch.set(fname,46);
    centralParts.push(ch);
  }

  let totalLocal = 0;
  localParts.forEach(it => totalLocal += it.lh.length + it.data.length);
  let centralSize = 0; centralParts.forEach(c => centralSize += c.length);
  const eocdSize = 22;
  const out = new Uint8Array(totalLocal + centralSize + eocdSize);
  let p = 0;
  localParts.forEach(it => { out.set(it.lh, p); p+=it.lh.length; out.set(it.data, p); p+=it.data.length; });
  const cdStart = p;
  centralParts.forEach(c => { out.set(c, p); p+=c.length; });
  const cdEnd = p;
  out.set([0x50,0x4b,0x05,0x06], p); p+=4;
  out.set([0,0], p); p+=2; out.set([0,0], p); p+=2;
  const entries = centralParts.length;
  out.set([ entries & 0xff, (entries>>8)&0xff ], p); p+=2;
  out.set([ entries & 0xff, (entries>>8)&0xff ], p); p+=2;
  out.set(uint32LE(centralSize), p); p+=4;
  out.set(uint32LE(cdStart), p); p+=4;
  out.set([0,0], p); p+=2;
  return out.buffer;
}

function generateDocxBlob(questionsList){
  const docXml = buildDocumentXml(questionsList);
  const files = {
    "[Content_Types].xml": contentTypesXml,
    "_rels/.rels": relsRelsXml,
    "word/_rels/document.xml.rels": docRelsXml,
    "word/document.xml": docXml
  };
  const zipBuf = makeZipBuffer(files);
  return new Blob([zipBuf], {type: "application/vnd.openxmlformats-officedocument.wordprocessingml.document"});
}

document.getElementById('exportBtn').addEventListener('click', ()=>{
  if(questions.length===0){ alert('पहले कम से कम एक प्रश्न जोड़ो'); return; }
  const blob = generateDocxBlob(questions);
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'mcq_export_tables.docx';
  a.click();
  setTimeout(()=> URL.revokeObjectURL(url), 3000);
});

/* small util (escape for preview) */
function escapeHtml(s){ if(!s) return ''; return s.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/\n/g,' '); }

</script>
</body>
</html>
